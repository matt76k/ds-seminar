---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---
確率
====

ここでは確率とはなにかを学んでいきます。

## 数学的確率

サイコロを使ったゲームで勝つために二人の天才数学者であるパスカルとフェルマーによって生み出された数学が確率といわれています。
その話にしたがって、サイコロの動きをプログラムで書いてみましょう。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
import random

def roll_die():
    return random.randint(1, 6)

print(f"サイコロを振った結果:{roll_die()}")
```

1行目は `import random` です。
これはPythonの標準ライブラリである `random` モジュールをインポートしています。
このモジュールは、乱数を生成するための関数を提供します。
サイコロのランダムな結果をシミュレートするのに必要です。

3-4行目で `roll_die()` 関数を定義しています。ここでは関数を定義する方法について学びます。
`def`は関数定義の開始を示します。
defのあとは関数の名前になります。今回は`roll_die`が関数名になります。
その次は`()`になっています。これはこの関数が引数を取らないためで、
引数を必要とする関数の場合は、この後に必要な引数の名前が続きます。
`)`の後にコロン（`:`）があります。ここから関数の本体が始まることを意味します。
関数の本体は、関数名よりも一つ分インデントされます。これでどこが本体かが視覚的に分かりやすくなっています。
`return`は関数の結果を返すために使用します。ここでは`random.randint(1, 6)`の結果を返しています。
`randint(a, b)`は$a \leq n \leq b$のランダムな整数を返す関数です。

まとめると、`roll_die`関数は、1から6までのランダムな整数を返します。これはサイコロを1回振ることをシミュレートしています。

6行目では、`roll_die`関数の実行結果を出力しています。
この行を実行するたびに、新しいランダムな結果が表示されますが、これは実際にプログラムを動かして確認してください。

こうした1つずつの試行結果を**根元事象**といいます。
そして、すべての可能な根元事象を集めた集合を**標本空間**（$\Omega$または$S$で表します）、標本空間の任意の部分集合を**事象**といいます。
たとえばサイコロの目で3が出る事象$A = \{3\}$や、サイコロで偶数の目が出る事象$B = \{2, 4, 6\}$が考えられます。
また、サイコロの場合の標本空間は$S = \{1, 2, 3, 4, 5, 6\}$となります。

確率は$P(A)$として表します。
これは事象$A$が起こる確率を意味し、計算方法は式{eq}`prob`になります。

```{math}
:label: prob
P(x) = \frac{\text{事象Aが起こる場合の数}}{\text{すべての可能な根元事象の数}}
```

集合の演算として$\cup$と$\cap$があります。
これはそれぞれ和集合と積集合（共通部分）を計算する演算です。
$A \cup B$は`AまたはB`の要素からなる集合です。
たとえば、$A = \{1, 2, 3\}$, $B = \{3, 4, 5\}$のとき、$A \cup B = \{1, 2, 3, 4, 5\}$となります。
$A \cap B$は`AかつB`の要素からなる集合です。
たとえば、$A = \{1, 2, 3\}$, $B = \{3, 4, 5\}$ のとき、$A \cap B = \{3\}$となります。
これらの演算は確率論において重要な役割を果たします。

式{eq}`prob`と集合の演算から、以下の公理がいえます。

1. 任意の事象$A$に対して、確率は0以上1以下です。
   ```{math}
   0 \leq P(A) \leq 1
   ```

2. 標本空間Sの確率は1です。
   ```{math}
   P(S) = 1
   ```

3. 事象$A$と事象$B$が排反（$A \cap B = \emptyset$）なら、$A$と$B$の和集合の事象の確率はそれぞれの事象の確率の和に等しい。
   ```{math}
   P(A \cup B) = P(A) + P(B)
   ```

空集合$\emptyset$も事象として考えられ、これを**空事象**といいます。
たとえばサイコロで考えるとすると、サイコロを振ると分裂をして2個のサイコロになり12が出るという事象はあり得ないので、
空事象となり、確率は0になります。

以上の概念と計算方法に基づいて求められる確率を数学的確率といいます。

## 統計的確率

統計的確率は、実験や観察を繰り返し行って得られた結果から確率を推定する方法です。
これは数学的確率と対比され、理論上の確率と実際の結果がどの程度一致するかを確認するのに役立ちます。

サイコロを1024回振るプログラムを書き、5の目が出る確率が理論値の$\frac{1}{6}$に近いかどうかを確認してみましょう。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
import random

def roll_die():
    return random.randint(1, 6)

def experiment(num_rolls):
    count_fives = 0
    for _ in range(num_rolls):
        if roll_die() == 5:
            count_fives += 1
    return count_fives

num_rolls = 1024
result = experiment(num_rolls)

observed_probability = result / num_rolls
theoretical_probability = 1 / 6

print(f"5の目が出た回数: {result}")
print(f"観測された確率: {observed_probability:.4f}")
print(f"理論上の確率: {theoretical_probability:.4f}")
print(f"差: {abs(observed_probability - theoretical_probability):.4f}")
```

8行目のforのループ変数はアンダースコア（`_`）になっています。
この変数の値自体はループ本体で使用されません。
これは、ループの中で特にループ変数を使う必要がない場合にPythonでよく使われる慣習になります。

結果を見ると5の出る確率は、理論値の$\frac{1}{6}$に近いと分かります。

試行回数が増えるほど、観測された確率は理論上の確率に近づく傾向があります（**大数の法則**）。
しかし、有限回の試行では、常に誤差が存在します。
この方法は、理論的に確率を計算することが難しい場合や、実際の現象が理論通りに振る舞うかを確認する場合に有用です。
統計的確率は、科学実験、品質管理、アンケート調査など、様々な分野で広く使用されています。

## 条件付き確率と乗法定理

サイコロ以外にもゲームで使われる道具としてトランプがあります。

ジョーカーを除いた52枚の標準的なトランプから1枚引いたときのプログラムを書いてみます。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
from itertools import product
from random import shuffle 
  
Suits = ["♣", "♦", "♥", "♠"]
Ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'] 
  
deck = list(product(Suits, Ranks))
shuffle(deck)

picked = deck[0]
print(f"{picked[0]} {picked[1]}")
```

1行目は`itertools`ライブラリの`product`関数をインポートしています。
`product`関数は、与えられたリストから全ての可能な組み合わせを生成します。
2行目は`random`ライブラリの`shuffle`関数をインポートしています。
これはリストの要素をランダムに並べ替えるために使用されます。

Suitsリストは4つのカードスート（クラブ、ダイヤ、ハート、スペード）、Ranksリストは13のカードランク（A, 2, 3, ..., Q, K）を定義しています。

7行目はすべてのスートとランクの組み合わせを生成し、それをリストに変換しています。これにより、52枚のカードデッキが作成されます。
8行目はdeckリストの要素をランダムに並べ替えています。これにより、カードがシャッフルされます。
9行目でシャッフルされたデッキの最初のカード（インデックス0）を選択し、
10行目でそのカードを表示しています。

では、52枚のトランプからカードを1枚引いたとき、そのカードがエースである確率はいくつでしょうか？

エースは各スート（マーク）に1枚ずつ、計4枚あります。
そのため、確率は$\frac{4}{52} = \frac{1}{13}$となり、およそ7.69\%となります。

では、カードを引いてエースだと分かりましたが、そのスートは忘れてしまったとします。
このとき、そのカードがスペードである確率はいくつでしょうか。

このような問題を解くときに、**条件付き確率**を使います。

事象Aが起きた条件のもとで事象Bが起きる確率を、Aが与えられたもとでのBの条件付き確率といい、式{eq}`prob-con`と表します。

```{math}
:label: prob-con
P(B | A) = \frac{P(A \cap B)}{P(A)}
```

式{eq}`prob-con`は式{eq}`prob-con2`のように式変形でき、これを乗法定理といいます。

```{math}
:label: prob-con2
P(A \cap B) = P(B | A)P(A)
```

先ほどの問題を条件付き確率を使って解きましょう。

事象を

- A: カードがエースである
- B: カードがスペードである

とすると、求めたい確率は$P(B|A)$と表せます。

エースである確率$P(A)$は$\frac{4}{52} = \frac{1}{13}$、
エースかつスペードである確率$P(A \cap B)$は$\frac{1}{52}$となります。

式{eq}`prob-con`に代入して考えると

```{math}
P(B|A) = \frac{P(A \cap B)}{P(A)} = \frac{\displaystyle\frac{1}{52}}{\displaystyle\frac{1}{13}} = \frac{1}{4}
```

となり、引いたカードがエースだと分かっている条件下で、そのカードがスペードである確率は$\frac{1}{4}$となります。

この結果は直感的にも理解できます。
52枚のデッキには4枚のエースがあり、そのうち1枚がスペードのエースです。
エースを引いたことが分かっている時点で、可能性は4枚のエースに絞られ、そのうちの1枚がスペードなので、確率は$\frac{1}{4}$となります。

条件付き確率の考え方は、多くの現実世界の問題を解く際に非常に有用です。

たとえば

- 医療診断: ある症状が見られる条件下で、特定の病気である確率
- 品質管理: 特定の製造工程を経た製品が不良品である確率
- 天気予報: 特定の気象条件下で雨が降る確率

これらの問題は、全て条件付き確率の考え方を応用して解けるでしょう。

次にスペードのエースを引く確率を乗法定理を使用して求めましょう。

乗法定理（式{eq}`prob-con2`）を使うと

```{math}
P(A \cap B) = P(B | A)P(A) = \frac{1}{4} \times \frac{1}{13} = \frac{1}{52}
```
となり、スペードのエースを引く確率は$\frac{1}{52}$となります。

この結果は直感的にも理解できます。
52枚のデッキの中にスペードのエースは1枚しかないため、その1枚を引く確率は$\frac{1}{52}$となります。

乗法定理を使用すると、複雑な確率問題を小さな部分に分解し、
それぞれの部分の確率を掛け合わせて全体の確率を求めれます。
この方法は、特に条件付き確率が関与する問題や、複数の独立した事象が連続して起こる確率を計算するときに非常に有用です。
