---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.5
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---
中心傾向の指標
==============

中心傾向の指標とは、データの中心的な値や典型的な値を表す統計量です。
主に以下の3つがあります。

- 平均値（算術平均）
  - すべての値の合計をデータ数で割った値
  - 最も一般的に使用される指標
  - 外れ値の影響を受けやすい
- 中央値
  - データを小さい順に並べたときの真ん中の値
  - 偶数個のデータの場合は、中央の2つの値の平均
  - 外れ値の影響を受けにくい
- 最頻値
  - データの中で最も頻繁に現れる値
  - 複数の最頻値が存在する場合もある

これらの指標は、データの分布（ばらつき具合）や性質によって適切な使用方法が異なります。
例えば、正規分布[^normal]に近いデータでは平均値が適していますが、極端な外れ値がある場合は中央値が適しています。

これらの指標を組み合わせて使用すれば、データの特徴をより正確に把握できます。

[^normal]: 平均値を中心とした左右対称の形状をしており、 自然界や社会現象に広く見られるデータの分布パターン。詳しくは、[正規分布](subsec-normal)のところで説明。

## 平均（Average）

統計で最も知られている用語としては、**平均値**が挙げられるでしょう。
例えば、A君の5教科の点数が{numref}`01-table-A-score`だとします。

```{table} A君の5教科
:name: 01-table-A-score

|国語|数学|社会|理科|英語|
|---|---|---|---|---|
|75|82|68|90|78|
```

この場合、{index}`平均値<へいきんち - 平均値>`（Average）を求めるには式{eq}`math-average`のように計算できます。

```{math}
:label: math-average
Average = \frac{75 + 82 + 68 + 90 + 78}{5} = \frac{393}{5} = 78.6
```

では、この計算を行うプログラムをPythonで書いてみましょう。

```{code-cell}
:tags: [remove-output]
scores = [75, 82, 68, 90, 78]
average = (scores[0] + scores[1] + scores[2] + scores[3] + scores[4]) / 5
print("Average:", average)
```

このプログラムが何をしているか1行ずつ説明していきます。

1行目はデータの準備をしています。
コンマ（,）で区切られた5つの数字はA君の5教科の点数を表しています。
カギ括弧（[]）で囲むことで**リスト**という方法で5教科の点数をひとまとめにしています。
リストはデータを整理して保存する方法の1つでPythonではよく使われます。
`scores`はリストに付けられた名前になります。
この名前を**変数**といいます。
Pythonでは等式（=）を挟んで右側にデータを、左側に変数を置いてデータに名前をつけます。
データに名前をつけると、後からその名前を使ってデータにアクセスできます。

変数のイメージは重要なので、ここで詳しく説明します。
変数には名前があり、その名前からデータを指している名札のようなものだと思ってください。
そのイメージを{numref}`variable`に示します。

```{figure} variable.png
:name: variable

変数とデータの関係
```

2行目は平均値の計算をしている部分になります。
`scores[0]`は、リストの0番目にある値（75）を取り出しています。
カギ括弧の中の数字は**インデックス**（index）と呼ばれ、リストでの位置を表しています。
（/）は割り算の意味になります。リストの全ての値を足して5で割った結果に`average`という名前をつけています。

```{note}
Pythonではリストの最初の値の位置は1からではなく、0からはじまるので注意しましょう。
```

3行目は計算結果を画面に表示しています。
`print`は、()の中に書かれた内容を画面に表示する**関数**です。
関数は通常、カッコで囲まれたデータ（**引数**）を受け取り、そのデータに処理を行い、その結果として値を返します。
基本的には、関数は引数を取り値を返しますが、`print`のように値を返さない関数や引数を取らない関数もあります。

関数は初めて出てくる用語なので、もう少し具体的に説明します。
例えば、足し算は、`2`と`3`という引数を2つ渡し、`5`という結果が値として返ってくる関数と見ることができます。
このように、関数に引数を与えて使うことを、「引数を渡して関数を呼ぶ」と言います。

3行目ではprint関数に2つの引数を渡しています。
1つ目は "Average:" という**文字列**で、2つ目は`average`という変数です。
コンマ（,）で引数を区切ると、複数のデータを1つの`print`で表示できます。

**文字列**とはPythonが扱えるデータの種類の1つです。
今までに出てきたデータの種類としては、5教科の点数で使った**整数**があります。
文字列や整数は単一の値を表す基本的なデータの型です。

一方、リストは複数の値をまとめて扱う方法で、データ構造と呼ばれます。
データ構造には、データを整理し効率的に操作するための仕組みがあります。
リストの場合、複数のデータを順序付けて保存し、個々のデータに簡単にアクセスできるという特徴があります。

```{note}
printに変数を渡すと、その変数の指している値を表示します。
正確には違いますが、ここではそのような理解で大丈夫です。
```

プログラムを実行すると、出力結果は次のようになります。

```{code-cell}
:tags: [remove-input]
scores = [75, 82, 68, 90, 78]
average = (scores[0] + scores[1] + scores[2] + scores[3] + scores[4]) / 5
print("Average:", average)
```

さて、このプログラムではリストの要素を1つずつ取り出していますが、もっとわかりやすく書く方法があります。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
scores = [75, 82, 68, 90, 78]
average = sum(scores) / len(scores)
print(f"Average: {average}")
```

行の先頭にある数字は行番号を表していて、出力結果も続けて表示しています。
1行目は同じですが、2行目からが違っていますので、これも説明していきます。

`sum(scores)`はリストの中身を全て足した結果を計算してくれる関数です。
`sum`を使えば、`scores`の値をそれぞれのインデックスで値を取り出す必要がなくなります。
また、関数名（`sum`）がその動作を表しているため、処理が明確になります。

`len(scores)`はリストの要素数を教えてくれる関数です。
ここでは、`scores`の要素数なので5になります。
前のプログラムでは5と直接書いていましたが、この5がどのような意味を持つかは明確ではありませんでした。
`len(scores)`と書けば、リストの要素数という意味が明確になります。
ちなみに、`len`は`length`の省略形になります。

printには、`f"Average: {average}"`という文字列を渡しています。
これはf文字列（フォーマット文字列）と呼ばれる方法です。
f文字列では、中括弧{}の中に変数や式を直接書くと、その値が文字列の中に埋め込まれます。
今回の場合、`{average}`の部分に`average`変数の値が組み込まれて表示されます。

このプログラムは前のプログラムと比べて簡潔で分かりやすくなっただけでなく、
リストの要素数が変わったとしてもプログラムを書き直す必要がありません。

## 中央値（Median）

中央値はデータを小さい順に並べたとき、ちょうど中央にある値です。
データの数が偶数の場合は、中央の2つの値の平均を取ります。

平均値はデータの中に極端に大きい値や小さい値があるとその影響を受けてしまいます。
中央値はそのような影響を受けにくい特徴があります。
例えば、ある町の世帯年収を調べたいとしましょう。
その町に億万長者が1人いると平均値が大きく上昇しますが、中央値はほとんど影響を受けません。
このような場合、中央値の方が一般的な世帯の年収を正確に表します。
また、アンケートの満足度調査や成績の5段階評価など、数値に順序はあるが間隔に意味がない場合、中央値が適切です。

中央値を求めるプログラムを書いてみましょう。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
import statistics

scores = [75, 82, 68, 90, 78]
median = statistics.median(scores)
print(f"Median: {median}")
```

この例では、データを小さい順に並べると `[68, 75, 78, 82, 90]`となり、真ん中の78が中央値になり、その値が出力されます。

1行目は、中央値を計算する関数`median`を持った`statistics`モジュールを使えるように準備しています。
モジュールとは、関連する機能をまとめたものです。
多くの場合、それは関数の集合ですが、変数や定数なども含みます。
定数とは、プログラム内で変更されない固定の値です。
例えば、数学や物理学で使われる重要な定数（$\pi$とか）がこれになります。

Pythonには多くの機能がありますが、全ての機能を常に読み込んでおくと、プログラムの実行速度が遅くなったり、メモリを無駄に使ったりします。
そのため、必要な機能だけを`import`して使うようになっています。

通常、import文はプログラムの先頭に書きます。
これにより、そのモジュールの機能をプログラム全体で使えるようになります。

インポートしたモジュールの機能を使う時は、「モジュール名.関数名」の形式で書きます。
例えば、4行目のstatistics.median(scores)は、statisticsモジュールのmedian関数を使ってscoresの中央値を計算しています。

次は、statisticsモジュールを使わずに中央値を計算してみましょう。

プログラムを書くコツは、どうような手順でその作業を行うかを前もって考えておくことです。
料理を作る時と同じですね。処理の手順は**アルゴリズム**と呼ばれます。

中央値を求めるアルゴリズムを書くとすると次のようになります。

```{prf:algorithm} 中央値を求めるアルゴリズム
:label: median-algo
**入力:** データが入ったリスト

**出力:** 中央値

1. データを小さい順に並べ替える
2. データの個数$n$を求める
3. $n$が偶数なら
    1. 中央に近い2つの値の平均を返す
4. $n$が奇数なら
    1. 中央の位置にある値を返す
```

このアルゴリズムにしたがってプログラムを記述すると、次のようになります。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
scores = [75, 82, 68, 90, 78]
# データをソートする
sorted_scores = sorted(scores)
# データの個数nを求める
n = len(sorted_scores)

if n % 2 == 0: # nが偶数
    a = sorted_scores[n // 2 - 1]
    b = sorted_scores[n // 2]
    median = (a + b) / 2
else:
    median = sorted_scores[n // 2]
print(f"Median: {median}")
```

プログラムの説明をします。
1行目はデータの準備になります。データが入ったリストに`scores`という名前を付けています。

2行目はコメント文になります。
コメント文はプログラムで実行されません。
Pythonでは`#`以降の文がコメントになります。
あとからプログラムを見直したいときなどにコメントを付けておくと便利です。
ただし、プログラムそれ自体が分かりやすければとコメントは書かなくても構いません。
分かりやすいプログラムを書くように心がけましょう。

3行目の`sorted`関数はリストを並び替えた**新しいリスト**を作ります。
`sorted_scores`という変数は、その新しいリストを指している点に注意しましょう。

5行目はソートした（並び替えた）データの個数に`n`という名前を付けています。
アルゴリズムの2のステップに対応します。

7行目と11行目にある`if`と`else`は**条件分岐**というプログラムの処理の流れを制御する文になります。
アルゴリズムの中の偶数と奇数で中央値の求め方を変えている部分に対応します。
ちなみに、`if`と`else`は予約語という特別な名前なので、変数の名前として使えません。

if文の書き方について説明します。
if文はifのあとに条件があり、その式の最後に`:`（コロン）があります。
**条件が真**ならコロンのあとの空白で揃えられた部分のプログラムが実行されます。
Pythonでは見た目で処理がわかりやすくなるように、
プログラムを空白で揃える**インデント**という方法で処理の流れを表します。
このプログラムだと条件が真の時に実行されるプログラムは8-10行目になります。
elseは条件に合わなかった場合の処理を記述します。
こちらも、ifと同じように最後はコロンで、インデントされたプログラムが実行されます。
条件に合わなかった場合の処理が必要ない場合は、elseを省略できます。

さて、それでは7-10行目までを詳しく説明していきます。

ifのあとにある文（`n % 2 == 0`）は条件と呼ばれ、nが偶数かどうかを調べています。
Pythonでは、整数への演算として四則演算以外にも様々種類があり、`%`は割り算の余りを計算してくれます。
`==`は比較演算子といい、左右の値が同じなら`True`（真）、そうでないなら`False`（偽）を返します。
以上のことから、`n % 2 == 0`は、データの個数`n`を2で割った余りが0なら`n`は偶数であるという意味になります。

8-9行目の`//`は整数除算を表しています。例えば、`7 // 2` は3になります。
`7 / 2`だと3.5となり、整数の結果が得られないため、ここでは`//`を使っています。
10行目で中央に近い2つの値の平均を計算し、`median`という名前を付けています。

11-12行目は中央の位置にある値に`median`という名前を付けています。

### 良いプログラムを書くには

今まで見てきたようにプログラムの書き方は複数あります。
ライブラリの機能を使っても良いし、自分で実装しても良いのです。
人によってはここで説明した中央値を求めるアルゴリズムと異なった方法を考えてプログラムを書くかもしれません。

このようにプログラムの書き方は様々ですが、良いプログラムを書く原則があります。
その1つが**DRY原則**として知られています。

DRYは`Don't Repeat Yourself`（自分自身を繰り返すな）の頭文字です。
この原則は、ソフトウェア開発において同じプログラムやロジックを繰り返し書くことを避けるべきだという考え方です。
DRY原則の利点としては以下の点があります。

- プログラムの保守性向上
- バグの可能性減少
- プログラムの一貫性の維持
- プログラムの変更が容易

例えば、先ほどの中央値を計算するプログラムは以下のように書き直せます。

```{code-cell}
scores = [75, 82, 68, 90, 78]
sorted_scores = sorted(scores)
n = len(sorted_scores)
median = sorted_scores[n // 2]

if n % 2 == 0: # nが偶数
    median = (sorted_scores[n // 2 - 1] + median) / 2

print(f"Median: {median}")
```
`sorted_scores[n // 2]`が何度も出てきているため、先に計算するように移動しています。
プログラムが簡潔になり、条件分岐が1つになったことで理解しやすくなっています。

プログラムが短ければ短いほど理解しやすいとは限りません。
また、人によって理解しやすいプログラムは異なります。
プログラミング経験が半年の人と10年の人では習熟度が異なるためです。

## 最頻値（Mode）

最頻値は、データの中で最も頻繁に現れる値です。

中央値と同様に極端に大きいまたは小さい値に影響を受けにくい特徴があります。
例えば、ある店舗での1日の客数を調べるとします。
通常は50人程度ですが、特別なイベントがあった日に500人が来店したとしても、最頻値は変わりません。
このような場合、最頻値は店舗の典型的な1日の客数をより正確に表します。

最頻値の大きな特徴は、順序尺度や名義尺度のデータに適用できる点です。

 - 順序尺度
   - データに順序はあるが、間隔に意味がない尺度。例えば、「満足度（非常に不満、不満、普通、満足、非常に満足）」や「学歴（小学校、中学校、高校、大学）」などがこれにあたります。これらは順序付けできますが、各段階の間隔が等しいとは限りません。
- 名義尺度
  - データに順序がなく、単に分類を示す尺度です。例えば、「好きな色」「出身地」「職業」などがこれにあたります。これらは順序付けができず、単にカテゴリーを示します。

Pythonを使って最頻値を計算するプログラムを書いてみましょう。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
from statistics import mode

scores = [75, 82, 68, 90, 78, 82, 75, 68, 82]
mode_value = mode(scores)
print(f"Mode: {mode_value}")
```

1行目は、statisticsモジュールからmode関数をインポートしています。
中央値のプログラムとは少し書き方が異なるので注意してください。
このインポート方法は、特定の関数だけをモジュールからインポートする方法です。
これにより、`mode`関数を直接使用できるようになり、`statistics.mode`と書く必要がなくなります。

3行目で、サンプルデータを用意しています。このデータでは82が最も頻繁に現れています。
4行目で、mode関数を使って最頻値を計算し、その結果にmode_valueという名前を付けています。
5行目で、計算結果を表示しています。

次に、statisticsモジュールを使わずに最頻値を計算するプログラムを書いてみましょう。

まず、アルゴリズムを考えます。

```{prf:algorithm} 最頻値を求めるアルゴリズム
:label: mode-algo
**入力:** データが入ったリスト

**出力:** 最頻値

1. データの各値の出現回数を数える
2. 最も多く出現した回数を見つける
3. その回数で出現した値（最頻値）を返す
```

このアルゴリズムに従ってプログラムを書くと、次のようになります。

```{code-cell}
---
mystnb:
  number_source_lines: true
---
scores = [75, 82, 68, 90, 78, 82, 75, 68, 82]

# 各点数の出現回数を数える
score_counts = {}
for score in scores:
    if score not in score_counts:
        score_counts[score] = 0
    score_counts[score] = score_counts[score] + 1

# 最も多く出現した回数を見つける
max_count = 0
for count in score_counts.values():
    if count > max_count:
        max_count = count

# その回数で出現した点数（最頻値）を見つける
for score, count in score_counts.items():
    if count == max_count:
        print(f"最頻値: {score}")
        break
```

このプログラムについて説明します。

4行目は辞書（dictionary）というデータ構造を準備し、`score_counts`という名前をつけています。
辞書は、キーと値のペアを格納するデータ構造で、ここではスコア（キー）とその出現回数（値）を保存します。

5-8行目は**ループ**という処理を行っています。
ループとはある処理を繰り返し行う方法です。
インデントされた6-8行目をループ本体（loop body）といい、この部分が繰り返し実行されます。
5行目にある`for`は予約語で、`if`と同様に変数名として使えません。
forの後にある`score`は**ループ変数**といい、ループ本体でのみ使われる変数になります。

5行目では、`scores`からリストの要素を1つずつ取り出し、その要素に`score`という名前を付けています。
リストの中身すべてに対して、ループ本体を実行します。
ちなみに、`in`も予約語です。

6行目の`not`は否定になります。
つまり、6行目の意味は`score_counts`にscoreをキーとして設定していないなら7行目を実行するという意味になります。
ここでの`in`と5行目の`in`は使い方が違うので注意しましょう。

7行目は、`score`をキーとして、そのペアの値を0としています。
4行目は辞書データの準備だけなので、キーもそのキーのペアとなる値も準備されていません。
そのため、7行目でキーとそのキーの値を設定する必要があります。
`scores_counts[score]`というようにカギ括弧を使ってキーのペアの値にアクセスしている点に注意しましょう。
リストの場合はカギ括弧の中はインデックスでしたが、辞書の場合はキーになる点が異なります。
辞書はリストのように順番にデータを保存していませんが、プログラムでは似たような形でデータにアクセスします。

8行目は、`score`をキーとしたペアの値に1足しています。
（=）の右側にも左側にも`scores_counts[score]`がありますが、
同時に値にアクセスするのではなく、右側の計算を先に実行して、その結果を左側に代入しています。
このような値を更新する処理は頻繁に現れるので、`score_counts[score] += 1`のように簡略した書き方もあります。

11-14行目は、最も多く出現した値の回数（最大の出現回数）を見つけるためのループです。

11行目は最大の出現回数を保存するためのmax_countという変数を準備しています。
最初は0という値を入れていますが、このように最初に値を準備することを**初期化**といったります。

12行目の`score_counts.values()`について説明します。
`score_counts`は辞書というキーとペアの値が入ったデータ構造でした。
プログラムの例でいうと、[(75, 2)、(82, 3)、(68, 2)、(90, 1)、(78, 1)]のようにキーと値の組みになっています。
`score_counts.values()`はこのデータの値の部分のみをリストとして取り出す関数です。
この例では [2, 3, 2, 1, 1] となります。

13行目のif文で、`count`が`max_count`より大きければ、
14行目の代入文でmax_countを更新します。
このループが終わると、max_countには出現回数が一番大きい値が保存されています。

17-20行目は、最頻値（つまり、最大出現回数で出現した数）を見つけるためのループです。
17行目の`score_counts.items()`は、辞書の各キーと値のペアをタプルとして返します。
この例では、[(75, 2), (82, 3), (68, 2), (90, 1), (78, 1)] のようなリストを返します。

`for score, count in score_counts.items():`は、
このリストの各要素（タプル）を score と count という2つの変数に分けて代入します。
具体的には最初のループでは、`score`は75、`count`は2、次は`score`は82、`count`は3というように続きます。

18行目のif分で、現在の`count`が最大出現回数と等しいかどうかをチェックします。
19行目では、最大出現回数の`score`を最頻値として出力します。
20行目の`break`は、ループを即座に終了させる命令です。
最頻値が見つかったらそれ以降のループの処理を終わらせます。
今回の例では初めて見つかった最頻値だけを表示するため、複数の最頻値がある場合はすべて表示したい場合は、`break`を削除するなどの変更が必要になります。